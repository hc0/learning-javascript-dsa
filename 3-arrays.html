<!DOCTYPE html> 
<html> 
  <head> 
    <meta charset="UTF-8"> 
  </head> 
  <body>
    <p>paragraph</p>
    <script>

//Há j maneiras de se criar um array novo

/*
 *  Três construtores ruins para Array
 *
 *  Um array é um objeto. Você pode usar o construtor da classe Array para criar esse objeto de três formas:
 **/

let filmes = new Array() //vazio
let filmes = new Array(3) //tamanho
let filmes = new Array ("LOTR", "Twin Towers", "Ze Kingz") //elementos

/*
 * Mas usar esse construtor não é considerado boa prática (?). Existem outras formas (três construtores bons):
 * */

 let filmes = []
 let filmes = [3] //não se faz isso, BURRO! Você criou um array com UM elemento 3
 let filmes = ["LOTR", "Twin Towers", "Ze Kingz"]
 
 /*
  * Agora usando métodos da classe Array:
  *
  * */
 //new Array de tamanho tal, depois fill com um elemento
let numbers6 = new Array(6).fill(5)

//Criando um array a partir de outro com Array.from(outro):
let numbers = ["LOTR", "Twin Towers", "Ze Kingz"]
let numbers2 = Array.from(numbers)

//Array.of usa os argumentos para fazer um array
let numbers3 = Array.of("LOTR", "Twin Towers", "Ze Kingz")

//Criando um array a partir de outro com Array.of(operador spread em outro array)
let numbers4 = Array.of(...numbers3)

//Criando um array a partir de dois ou mais:
let negativeNumbers = [-3,-2,-1]
let zero = 0
let positiveNumbers = [1,2,3]
let allNumbers = negativeNumbers.concat(zero, positiveNumbers) //é possível concatenar com elementos ou arrays

 
/*
 * Adicionar um elemento
 *
 * Em Javascript o tamanho do array é dinâmico
 * */

//enfia um no final
filmes[filmes.length] = "hobbiz" //fácil demais, agora 4 métodos:

//enfia um no final
filmes.push("hobbiz")

//enfia mais de um no final
filmes.push("hobbiz", "dwarvz")

//enfia um no começo
filmes.unshift("orcs") 

//enfia mais de um no começo
filmes.unshift("orcs", "goblins")

/*
 * Remover um elemento
 * 
 * */

//Remover do fim do array
filmes.pop()

//Remover do início do array (e reduzir o tamanho)
filmes.shift()

//Remover um ou mais de um elemento (contíguo) do array e guardá-lo(s)
let filmesRemovidos = filmes.splice(2,3) //índice, quantidade

//Inserir de volta a parte que removeu e guardou (ou enfiar um array no meio do outro)
filmes.splice(2,0,...filmesRemovidos) //primeiro index, quantidade a remover (0), o resto dos elementos é o que será inserido


/*
 * MÉTODOS DA CLASSE Array
 * */

//Array.from também aceita uma função de mapeamento
let evens = Array.from(numbers, x => x % 2 === 0)

//fill também permite que se passe a posição inicial
numbers5.fill(0,1)

//fill também permite que se passe a posição inicial e final
numbers5.fill(0,1,3)

//Método copyWithin(target, start, end). Copiar do array para o próprio array.
let copyArray = [1,2,3,4,5]
copyArray.copyWithin(0,3)

/*
 * Imprimir um array bidimensional
 * */
avgTemps = []
avgTemps[0] = [0,1,2,3,4]
avgTemps[1] = [5,6,7,8,9]
console.table(avgTemps)


/*
 * ITERAR UM ARRAY SEM USAR UM FOR, NEM UM ITERADOR
 * */
let numbers = [0,1,2,3,4,5,6,7,8,9]

//função que vai usar para iterar. O retorno da função será interpretado como booleano.
const isNegative = number => {
 const result = number < 0
 console.log(number, result)
 return result
}

const isntNegative = number => {
 const result = number >= 0
 console.log(number, result)
 return result
}

//iterando o array com every
numbers.every(isNegative) //Roda a função em cada elemento em sequência. Para precocemente se uma rodada retornar false. Retorna o retorno da última rodada. Use sempre uma função que retorne booleano.
numbers.every(isntNegative)

//iterando o array com some
numbers.some(isNegative) //Que nem o every. Só para quando o array acaba ou uma iteração retorna true.
numbers.some(isntNegative)

//iterando o array com forEach
numbers.forEach(isEven) //A diferença do forEach pros every e some é que ele não retorna nada, e itera todos os elementos independente do resultado

//pode escrever a função dentro do forEach, some, ou every se preferir (meio feio)
numbers.forEach(number => number % 2 === 0)
numbers.some(number => number % 2 === 0)
numbers.every(number => number % 2 === 0)

//iterar com map gera um array novo com os retornos da função
const isEven = x => x % 2 === 0
const myMap = numbers.map(isEven)

//iterar com filter é que nem com map, só que em vez dos retornos da função, o novo array terá os elementos para os quais os retornos avaliavam como true
const myEvenNumbers = numbers.filter(isEven)

//usando uma função que mapeia um array reduzindo-o a uma coisa só (num acumulador)
const reducer = (accumulator, currentValue) => accumulator + currentValue //é sempre uma função com essa assinatura (accumulator, currentValue)
console.log(numbers.reduce(reducer))

//iterando usando "for const of"
for(const number of numbers) {
  console.log(number)
}

/*
 * ITERAR UM ARRAY USANDO UM ITERADOR
 * Existem vários sabores de iterador
 * */

let letters = ['a', 'e', 'i', 'o', 'u']

//Symbol.iterator é o índice de uma função que se chama e retorna um iterador de valores para aquele array. É o mais seboso e ninguém usa
let iterator = letters[Symbol.iterator]()
console.log(iterator.next()) //iterator.next() retorna um objeto com dois parâmetros: value e done. Quando o array acaba, value = undefined e done = true
console.log(iterator.next().value) 
console.log(iterator.next().done)

//array.entries() retorna outro iterador. A diferença do next de entries é que seu value é um objeto [indice, valor]. O done é a mesma coisa.
let entries = letters.entries(); //retrieve iterator of key/value
console.log(entries.next()); // value = [0, 'a'], done = false
console.log(entries.next().value); // [1, 'e']
console.log(entries.next().done);

//array.keys() é igual a Symbol.iterator, exceto que em value vai o índice e não o valor
let keys = letters.keys(); //retrieve iterator of keys
console.log(keys.next()); // {value: 0, done: false } done false means iterator has more values
console.log(keys.next().value);
console.log(keys.next().done);

//Array.values é igualzinho a Symbol.iterator
let values = letters.values();
console.log(values.next());
console.log(values.next().value);
console.log(values.next().done);

/*
 * SORTING
 * */
let numbers = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]

//reverse() reverte o array
numbers.reverse()

//sort() assume que todos os elementos são strings e ordena ASCIImente
numbers.sort()

//Se não quiser que sort interprete os elementos como strings e ordene ASCIImente, entregue-lhe uma função de comparação
numbers.sort((a,b) => a - b)

//Crie uma função de comparação para ordenar objetos de acordo com o que quiser
let movies = [{name: 'Matrix', year: 2004},
              {name: 'LOTR', year: 2006},
              {name: 'Alien', year: 2008}]

function compareMovies(a, b) {
 if (a.year < b.year)
  return -1
 else if (a.year == b.year)
  return 0
 else
  return 1
}

movies.sort(compareMovies)

//sort lexicografa usando os valores ASCII, portanto o alfabeto maiúsculo vem antes do minúsculo
let countries = ["Burkina Faso", "burkina faso", "zambia", "Zambia", "Zimbabwe", "Botswana"]
countries.sort() //["Botswana", "Burkina Faso", "Zambia", "Zimbabwe", "burkina faso", "zambia"]
//como corrigir isso:
function compareCountries(a,b) {
 if (a.toLowerCase() < b.toLowerCase())
  return -1
 else if (a.toLowerCase() === b.toLowerCase())
  return 0
 else
  return 1
}
countries.sort(compareCountries) //["Botswana", "Burkina Faso", "burkina faso", "zambia", "Zambia", "Zimbabwe"]
//se quiser que as minúsculas venham sempre antes
countries.sort((a,b) => a.localeCompare(b)) //["Botswana", "burkina faso", "Burkina Faso", "zambia", "Zambia", "Zimbabwe"]

//para nomes com acentos use localeCompare
let names = ["Maève", "Maéve", "Maeve"]
names.sort()
names.sort((a,b) => a.localeCompare(b)) //["Maeve", "Maéve", "Maève"]

/*
 * BUSCA
 * */
let numbers = [13,1,2,5,3,4,4,5,169]

//indexOf() e lastIndexOf() retornam -1 quando não acham
console.log(numbers.indexOf(5))
console.log(numbers.lastIndexOf(5))
console.log(numbers.indexOf(8)) //retorna -1 porque não existe
console.log(numbers.lastIndexOf(8)) //retorna -1 porque não existe

//as funções find() e findIndex() recebem uma função de callback para encontrar o primeiro elemento que a satisfaça.
//Crie um callback recebendo os parâmetros (element, index, array). Use só o element
function multipleOf13(element, index, array) {
 if (element % 13 === 0)
  return true
 else
  return false
}
numbers.find(multipleOf13)
numbers.findIndex(multipleOf13)
let numbers2 = [1,2,3,4]
numbers2.find(multipleOf13) //undefined
numbers2.findIndex(multipleOf13) //-1

//função includes
let numbers = [13,1,2,5,3,4,4,5,169]
console.log(numbers.includes(5))
//função includes com starting Index
console.log(numbers.includes(5,3))
console.log(numbers.includes(5,4))
console.log(numbers.includes(5,8))

//Outputando um array em uma string
//toString() separa os elementos com vírgulas
numbers.toString()
//join() separa os elementos com o que você quiser
numbers.join('-')

/*
 * TYPED ARRAYS: bons para trabalhar com material binário
 * */
let array = new Int8Array(5)
let array = new Uint8Array(5)
let array = new Uint8ClampedArray(5) //valores maiores que 255 são clampeados para 255 ao invés de ser aplicado o módulo de 256
let array = new Int16Array(5)
let array = new Uint16Array(5)
let array = new Int32Array(5)
let array = new Uint32Array(5)
let array = new Float32Array(5)
let array = new Float64Array(5)

    </script> 
  </body> 
</html>